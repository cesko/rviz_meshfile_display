/* __ProtectedRegion_begin__ fileDoxy */
/**
 * @file rviz_meshfile_display.cpp
 * @author Christian Koch (christian.koch@dfki.de)
 * @brief Publish a meshfile to display in rviz
 * @version x.x
 * @date 2022-xx-xx
 * 
 * @copyright Copyright (c) 2020
 * 
 */
/* __ProtectedRegion_end__ fileDoxy */

/*
 * USER GUIDE
 * ==========
 * 
 * Note: This rospackage was autogenerated. 
 * 
 * **You, the user, should edit this file!** Here is how:
 * 
 *  - Only write code between the 'ProtectedRegion_begin' and
 *    'ProtectedRegion_end' statements! Code outside these protected
 *    regions will be deleted when regenerating.
 * 
 *  - The ros node is represented by an instance of RvizMeshfileDisplayNode.
 *    Add your functionality to this class.
 * 
 *  - Skeleton for the essential functions are provided. 
 *    For example an update()-function, that is called periodically. Add your
 *    core functionality here.
 * 
 *  - You can define class member variables in the protected field 'userData'
 * 
 *  - You can define custom member functions in the protected field 'userFunctions'
 * 
 * **You have access to the following Interfaces**
 * 
 * Publisher:
 *  - pub_visualization_marker        [visualization_msgs/Marker]            Rviz marker topic
 * To publish a message-object msg, call `pub_<topic_name>.publish(msg)`
 * 
 * Static Parameter:
 *  - config.meshfile                 [std::string]                          location of meshfile
 *  - config.frame_id                 [std::string]                          Parent frame
 *  - config.maker_ns                 [std::string]                          Marker namespace
 *  - config.x                        [double]                               Positon X
 *  - config.y                        [double]                               Positon Y
 *  - config.z                        [double]                               Positon Z
 *  - config.R                        [double]                               Rotation around X (Roll)
 *  - config.P                        [double]                               Rotation around Y (Pitch)
 *  - config.Y                        [double]                               Rotation around Z (Yaw)
 *  - config.angle_in_degree          [bool]                                 When true, angles (RPY) are interpreted as degrees
 *
 * Dynamic Parameter:
 *  - config.color_red                [double]                               red-value
 *  - config.color_green              [double]                               green-value
 *  - config.color_blue               [double]                               blue-value
 *  - config.color_alpha              [double]                               alpha-value
 *  - config.scale_x                  [double]                               
 *  - config.scale_y                  [double]                               
 *  - config.scale_z                  [double]                               
 *  - config.use_embedded_materials   [bool]                                 use embedded materials of meshfile
 */

// System
// ------
#include <iostream>
#include <string>
#include <sstream>
#include <vector>

// ROS
// ------
#include <ros/ros.h>
#include <dynamic_reconfigure/server.h>
#include <rviz_meshfile_display/rviz_meshfile_displayConfig.h>

// Interfaces
#include <visualization_msgs/Marker.h>

/* __ProtectedRegion_begin__ userIncludes */
// Add or adjust your dependencies here
#include <cmath>
#include <tf2/LinearMath/Quaternion.h>
/* __ProtectedRegion_end__ userIncludes */

namespace rviz_meshfile_display
{
using namespace rviz_meshfile_display;

struct RvizMeshfileDisplayConfig
{
    // Dynamic Parameter
    // -----------------
    double color_red = 0.5;
    double color_green = 0.5;
    double color_blue = 0.5;
    double color_alpha = 0.5;
    double scale_x = 1.0;
    double scale_y = 1.0;
    double scale_z = 1.0;
    bool use_embedded_materials = false;

    // Static Parameter
    // --------------
    std::string meshfile = "";
    std::string frame_id = "world";
    std::string maker_ns = "";
    double x = 0.0;
    double y = 0.0;
    double z = 0.0;
    double R = 0.0;
    double P = 0.0;
    double Y = 0.0;
    bool angle_in_degree = false;
};

class RvizMeshfileDisplayNode
{
    typedef rviz_meshfile_display::rviz_meshfile_displayConfig DynamicReconfigureType;

protected:

    // ROS Node Handle
    // ---------------

    // Public Node Handle
    ros::NodeHandle nh;
    // Private Node Handle
    ros::NodeHandle nhp;

    // ROS Parameter
    // -------------
    RvizMeshfileDisplayConfig config;
    dynamic_reconfigure::Server<DynamicReconfigureType> dynamic_reconfigure_server;
    dynamic_reconfigure::Server<DynamicReconfigureType>::CallbackType dynamic_reconfigure_callback;

    // ROS Interface
    // ------------- 

    // ### Publisher
    ros::Publisher pub_visualization_marker;

    // Timer
    // -----
    ros::Timer timer_main;

    // User Data
    // ---------
    /* __ProtectedRegion_begin__ userData */
    
    visualization_msgs::Marker marker_msg;

    /* __ProtectedRegion_end__ userData */


public:
    RvizMeshfileDisplayNode (ros::NodeHandle& nh, ros::NodeHandle& nhp)
    : config(), nh(nh), nhp(nhp)
    {
        // ### Initialize ROS Interfaces
        ROS_DEBUG("Initialize ROS Interfaces");

        // #### Parameter
        loadParameter();
        dynamic_reconfigure_callback = boost::bind(&RvizMeshfileDisplayNode::dynamicReconfigureCallback, this, _1, _2);
        dynamic_reconfigure_server.setCallback(dynamic_reconfigure_callback);

        // #### Publisher
        pub_visualization_marker = nhp.advertise<visualization_msgs::Marker>("visualization_marker", 1000);        

        // Timer
        // ####
        ROS_DEBUG("Start ROS Timer");
        timer_main = nh.createTimer( ros::Rate( 1 ), &RvizMeshfileDisplayNode::timerCallbackMain, this );
    

        /* __ProtectedRegion_begin__ constructor */

        marker_msg.header.frame_id = config.frame_id;
        marker_msg.type = visualization_msgs::Marker::MESH_RESOURCE; // 11
        marker_msg.mesh_resource = config.meshfile;

        marker_msg.pose.position.x = config.x;
        marker_msg.pose.position.y = config.y;
        marker_msg.pose.position.z = config.z;

        tf2::Quaternion quaternion;
        if (config.angle_in_degree) {
            quaternion.setRPY( M_PI/180.0*config.R, M_PI/180.0*config.P, M_PI/180.0*config.Y );  // Create this quaternion from roll/pitch/yaw (in radians)
        } else {
            quaternion.setRPY( config.R, config.P, config.Y );  // Create this quaternion from roll/pitch/yaw (in radians)
        }
        marker_msg.pose.orientation.x = quaternion.getX();
        marker_msg.pose.orientation.y = quaternion.getY();
        marker_msg.pose.orientation.z = quaternion.getZ();
        marker_msg.pose.orientation.w = quaternion.getW();

        /* __ProtectedRegion_end__ constructor */

        // ### Start Node
        ROS_DEBUG("Start Spinning");
        ros::AsyncSpinner spinner(0);
        spinner.start();
        ros::waitForShutdown();
    }

    ~RvizMeshfileDisplayNode()
    {
        /* __ProtectedRegion_begin__ destructor */

        /* __ProtectedRegion_end__ destructor */
    }

    // Timer Callback
    // --------------

    /* __ProtectedRegion_begin__ updateLoopMain */
    /**
     * @brief Main Timer Callback
     * To be edited by the user.
     */
    void timerCallbackMain (const ros::TimerEvent& event)
    {
        ROS_DEBUG("Update Loop (timer callback): main");
        // ROS_INFO_STREAM("All required interfaces available? " << (checkRequiredInterfaces() ? "yes" : "NO") );
        // ROS_INFO_STREAM("Timeouts? " << (checkTimeouts() ? "YES" : "no") );

        marker_msg.color.r = config.color_red;
        marker_msg.color.g = config.color_green;
        marker_msg.color.b = config.color_blue;
        marker_msg.color.a = config.color_alpha;
        marker_msg.scale.x = config.scale_x;
        marker_msg.scale.y = config.scale_y;
        marker_msg.scale.z = config.scale_z;
        marker_msg.mesh_use_embedded_materials = config.use_embedded_materials;

        pub_visualization_marker.publish(marker_msg);
    }
    /* __ProtectedRegion_end__ updateLoopMain */


    // ROS Parameter
    // -------------

    void loadParameter()
    {
        // Load ROS parameter from parameter server, if available.
        nhp.getParam("meshfile", config.meshfile);
        nhp.getParam("frame_id", config.frame_id);
        nhp.getParam("maker_ns", config.maker_ns);
        nhp.getParam("x", config.x);
        nhp.getParam("y", config.y);
        nhp.getParam("z", config.z);
        nhp.getParam("R", config.R);
        nhp.getParam("P", config.P);
        nhp.getParam("Y", config.Y);
        nhp.getParam("angle_in_degree", config.angle_in_degree);
        nhp.getParam("color_red", config.color_red);
        nhp.getParam("color_green", config.color_green);
        nhp.getParam("color_blue", config.color_blue);
        nhp.getParam("color_alpha", config.color_alpha);
        nhp.getParam("scale_x", config.scale_x);
        nhp.getParam("scale_y", config.scale_y);
        nhp.getParam("scale_z", config.scale_z);
        nhp.getParam("use_embedded_materials", config.use_embedded_materials);
    }

    void dynamicReconfigureCallback(DynamicReconfigureType &inconfig, uint32_t level)
    {
        /* __ProtectedRegion_begin__ dynamicReconfigureCallback */
        ROS_DEBUG( "Update dynamic parameter!" );
        /* __ProtectedRegion_end__ dynamicReconfigureCallback */

        config.color_red = inconfig.color_red;
        config.color_green = inconfig.color_green;
        config.color_blue = inconfig.color_blue;
        config.color_alpha = inconfig.color_alpha;
        config.scale_x = inconfig.scale_x;
        config.scale_y = inconfig.scale_y;
        config.scale_z = inconfig.scale_z;
        config.use_embedded_materials = inconfig.use_embedded_materials;
    }

    // User Functions
    // --------------

    /* __ProtectedRegion_begin__ userFunctions */

    bool checkTimeouts()
    {

        // auto now = ros::Time::now();
        // auto timeout = ros::Duration(5.0);


        return false;
    }
    
    bool checkRequiredInterfaces()
    {


        return true;
    }    

    /* __ProtectedRegion_end__ userFunctions */

};


} // Namespace

// ----------------------------------------------------------------------------

int main (int argc, char **argv)
{
    ros::init(argc, argv, "rviz_meshfile_display");
    
    ros::NodeHandle nh;
    ros::NodeHandle nhp("~");
    
    /* __ProtectedRegion_begin__ mainFunction */
    // if( ros::console::set_logger_level(ROSCONSOLE_DEFAULT_NAME, ros::console::levels::Debug) ) {
    //     ros::console::notifyLoggerLevelsChanged();
    // }
    /* __ProtectedRegion_end__ mainFunction */

    rviz_meshfile_display::RvizMeshfileDisplayNode node(nh, nhp);   
}

 